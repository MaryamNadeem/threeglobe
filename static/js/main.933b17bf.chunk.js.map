{"version":3,"sources":["globe.jpg","App.js","reportWebVitals.js","index.js"],"names":["scene","THREE","camera","window","innerWidth","innerHeight","renderer","antialias","setSize","setPixelRatio","devicePixelRatio","document","body","appendChild","domElement","sphere","vertexShader","fragmentShader","uniforms","globeTexture","value","load","globe","atmosphere","blending","side","scale","set","add","group","starGeometry","starMaterial","color","starVertices","i","x","Math","random","y","z","push","setAttribute","Float32BufferAttribute","stars","position","mouse","undefined","animate","requestAnimationFrame","render","rotation","gsap","to","duration","addEventListener","e","clientX","clientY","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"mNAAe,MAA0B,kC,cCanCA,EAAQ,IAAIC,IACZC,EAAS,IAAID,IACjB,GACAE,OAAOC,WAAaD,OAAOE,YAC3B,GACA,KAGIC,EAAW,IAAIL,IAAqB,CAAEM,WAAW,IACvDD,EAASE,QAAQL,OAAOC,WAAYD,OAAOE,aAC3CC,EAASG,cAAcN,OAAOO,kBAC9BC,SAASC,KAAKC,YAAYP,EAASQ,YAInC,IAAMC,EAAS,IAAId,IACjB,IAAIA,IAAqB,EAAG,GAAI,IAQhC,IAAIA,IAAqB,CACvBe,aAAa,uPAQbC,eAAe,4VAUfC,SAAU,CACRC,aAAc,CAAEC,OAAO,IAAInB,KAAsBoB,KAAKC,QAKtDC,EAAa,IAAItB,IACrB,IAAIA,IAAqB,EAAG,GAAI,IAQhC,IAAIA,IAAqB,CACvBe,aAAa,oMAMbC,eAAe,mQAQfO,SAAUvB,IACVwB,KAAMxB,OAIVsB,EAAWG,MAAMC,IAAI,IAAK,IAAK,KAC/B3B,EAAM4B,IAAIL,GACV,IAAMM,EAAQ,IAAI5B,IAClB4B,EAAMD,IAAIb,GACVf,EAAM4B,IAAIC,GAQV,IANA,IAAMC,EAAe,IAAI7B,IACnB8B,EAAe,IAAI9B,IAAqB,CAAE+B,MAAO,WAGjDC,EAAe,GAEZC,EAAI,EAAGA,EAAI,IAAMA,IAAK,CAG7B,IAAMC,EAA4B,KAAvBC,KAAKC,SAAW,IACrBC,EAA4B,KAAvBF,KAAKC,SAAW,IAErBE,EAAqB,MAAhBH,KAAKC,SAChBJ,EAAaO,KAAKL,EAAGG,EAAGC,GAG1BT,EAAaW,aACX,WACA,IAAIC,IAAuBT,EAAc,IAI3C,IAAMU,EAAQ,IAAI1C,IAAa6B,EAAcC,GAC7C/B,EAAM4B,IAAIe,GAEVzC,EAAO0C,SAASL,EAAI,GAEpB,IAAMM,EAAQ,CAAEV,OAAGW,EAAWR,OAAGQ,IAEjB,SAAVC,IACJC,sBAAsBD,GACtBzC,EAAS2C,OAAOjD,EAAOE,GACvBa,EAAOmC,SAASZ,GAAK,KACrBa,IAAKC,GAAGvB,EAAMqB,SAAU,CAAEZ,EAAa,GAAVO,EAAMV,EAASA,EAAc,IAAVU,EAAMP,EAASe,SAAU,IAG3EN,GAEA5C,OAAOmD,iBAAiB,aAAa,SAAAC,GACnCV,EAAMV,EAAKoB,EAAEC,QAAUrD,OAAOC,WAAc,EAAI,EAChDyC,EAAMP,EAAKiB,EAAEE,QAAUtD,OAAOE,YAAe,EAAI,KAOpCqD,MAJf,WACE,OAAO,qBAAKC,UAAU,SCjITC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASpB,OACP,cAAC,IAAMqB,WAAP,UACE,cAAC,EAAD,MAEF3D,SAAS4D,eAAe,SAM1BX,M","file":"static/js/main.933b17bf.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/globe.e337878b.jpg\";","import './App.css';\nimport * as THREE from 'three';\nimport globe from './globe.jpg';\nimport gsap from 'gsap';\nimport { Float32BufferAttribute } from 'three';\n//https://www.youtube.com/watch?v=vM8M4QloVL0&t=1450s\n// vertex shader is a program that runs for every vertex with in our geometry\n//glsl is a typed language\n// the main funtion in vertex.glsl will run once for every vertex\n// gl_Position is the x y z coordinate of the vertex\n// vertex shader is responsible for placing all the vertices in the correct position\n// fragment shader is responsible fro filling the space in between by giving them color or something\n//https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(\n  75,\n  window.innerWidth / window.innerHeight,\n  0.1,\n  1000\n);\n\nconst renderer = new THREE.WebGL1Renderer({ antialias: true });\nrenderer.setSize(window.innerWidth, window.innerHeight);\nrenderer.setPixelRatio(window.devicePixelRatio);\ndocument.body.appendChild(renderer.domElement);\n\n// create spehere\n// sphere geometry takes radius,width,height\nconst sphere = new THREE.Mesh(\n  new THREE.SphereGeometry(5, 50, 50),\n  // new THREE.MeshBasicMaterial({\n  //   map: new THREE.TextureLoader().load(globe)\n  // })\n  //vertex shader is boiler plate code to get the position working\n  // fragment shader has acces to vertex shader data such as vertices\n  // varying variable is used to passs the uv from vertex shader to pragment shader\n  // vectorNormal represents the direction of the vertex we are looping through\n  new THREE.ShaderMaterial({\n    vertexShader: `\n    varying vec2 vertexUV;\n    varying vec3 vertexNormal;\n    void main(){\n      vertexUV = uv;\n      vertexNormal =  normalize(normalMatrix *normal);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform sampler2D globeTexture;\n    varying vec2 vertexUV;\n    varying vec3 vertexNormal;\n    void main(){\n      float intensity = 1.05 - dot(vertexNormal, vec3(0.0,0.0,1.0));\n      vec3 atmosphere = vec3(0.3, 0.6, 1.0) * pow(intensity, 1.5);\n       gl_FragColor = vec4(atmosphere+texture2D(globeTexture, vertexUV ).xyz, 1.0);\n    }`,\n    // in uniform we declare all the different attributes we want to pass to our shader\n    uniforms: {\n      globeTexture: { value: new THREE.TextureLoader().load(globe) }\n    }\n  })\n);\n//create atmosphere\nconst atmosphere = new THREE.Mesh(\n  new THREE.SphereGeometry(5, 50, 50),\n  // new THREE.MeshBasicMaterial({\n  //   map: new THREE.TextureLoader().load(globe)\n  // })\n  //vertex shader is boiler plate code to get the position working\n  // fragment shader has acces to vertex shader data such as vertices\n  // varying variable is used to passs the uv from vertex shader to pragment shader\n  // vectorNormal represents the direction of the vertex we are looping through\n  new THREE.ShaderMaterial({\n    vertexShader: `\n    varying vec3 vertexNormal;\n    void main(){\n      vertexNormal = normalize(normalMatrix *normal);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform sampler2D globeTexture;\n    varying vec2 vertexUV;\n    varying vec3 vertexNormal;\n    void main(){\n      float intensity =pow(0.65 -dot(vertexNormal, vec3(0,0,1.0)), 2.0);\n       gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) *intensity;\n    }`,\n    blending: THREE.AdditiveBlending,\n    side: THREE.BackSide\n  })\n);\n\natmosphere.scale.set(1.1, 1.1, 1.1);\nscene.add(atmosphere);\nconst group = new THREE.Group();\ngroup.add(sphere);\nscene.add(group);\n\nconst starGeometry = new THREE.BufferGeometry();\nconst starMaterial = new THREE.PointsMaterial({ color: 0xffffff });\n\n// adding poistions for the starts\nconst starVertices = [];\n\nfor (let i = 0; i < 2000; i++) {\n  //math.random fives value from 0 to 1 so we sub 0.5 to get negative values\n  // multiply by 2000 to spread across screen\n  const x = (Math.random() - 0.5) * 2000;\n  const y = (Math.random() - 0.5) * 2000;\n  // as we want the stars behind globe that is why we are adding negative z\n  const z = -Math.random() * 2500;\n  starVertices.push(x, y, z);\n}\n// we telll tthe grouping is in 3\nstarGeometry.setAttribute(\n  'position',\n  new Float32BufferAttribute(starVertices, 3)\n);\n\n//this makes sure that we are rendering some material at each individual point rather than filling everything in\nconst stars = new THREE.Points(starGeometry, starMaterial);\nscene.add(stars);\n\ncamera.position.z = 15;\n\nconst mouse = { x: undefined, y: undefined };\n\nconst animate = () => {\n  requestAnimationFrame(animate);\n  renderer.render(scene, camera);\n  sphere.rotation.y += 0.001;\n  gsap.to(group.rotation, { y: mouse.x * 0.5, x: -mouse.y * 0.3, duration: 2 });\n};\n\nanimate();\n\nwindow.addEventListener('mousemove', e => {\n  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;\n  mouse.y = (e.clientY / window.innerHeight) * 2 - 1;\n});\n\nfunction App() {\n  return <div className=\"App\"></div>;\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}